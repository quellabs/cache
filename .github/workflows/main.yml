name: Sync to Public Repos
on:
  push:
    branches: [main]
    tags: ['v*', '*.*.*']
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no actual changes)'
        required: false
        default: false
        type: boolean

jobs:
  sync:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        package:
          - contracts
          - discover
          - dependency-injection
          - sculpt
          - objectquel
          - signal-hub
          - annotation-reader
          - canvas
          - canvas-objectquel
          - canvas-smarty
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.SYNC_TOKEN }}

      - name: Sync ${{ matrix.package }}
        run: |
          set -e
          echo "Syncing ${{ matrix.package }}..."
          if ! git subtree push --prefix=packages/${{ matrix.package }} \
            https://${{ secrets.SYNC_TOKEN }}@github.com/quellabs/${{ matrix.package }}.git main; then
            echo "❌ Failed to sync ${{ matrix.package }}"
            exit 1
          fi
          echo "✅ Successfully synced ${{ matrix.package }}"

  release:
    runs-on: ubuntu-latest
    needs: sync
    if: contains(github.event.head_commit.message, '[release]') || contains(toJSON(github.event.head_commit.modified), 'versioning/versions.json')
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.SYNC_TOKEN }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Release packages based on versions.json
        env:
          DRY_RUN: ${{ (github.event.inputs.dry_run || 'false') == 'true' }}
        run: |
          set -e
          echo "Checking versions.json for packages to release..."
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "🔍 DRY RUN MODE - No actual changes will be made"
          fi
          
          # Validate versions.json exists
          if [ ! -f "versioning/versions.json" ]; then
            echo "❌ versioning/versions.json not found"
            exit 1
          fi
          
          # Function to compare semantic versions
          version_gt() {
            test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
          }
          
          # Clean up any existing temp directories
          rm -rf temp-*
          
          # Read versions.json and process each package
          jq -r 'to_entries[] | "\(.key) \(.value)"' versioning/versions.json | while read package target_version; do
            echo "Checking $package..."
          
            # Validate version format (no 'v' prefix)
            if ! [[ "$target_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
              echo "  ❌ Invalid version format: $target_version (should be like 1.0.0)"
              continue
            fi
          
            # Fetch all tags and determine the highest semver tag
            if ! tags_response=$(curl -s -f -H "Authorization: token ${{ secrets.SYNC_TOKEN }}" \
              "https://api.github.com/repos/quellabs/$package/tags" 2>/dev/null); then
              echo "  ❌ Failed to fetch tags for $package (repo might not exist yet)"
              current_version="0.0.0"
            else
              current_version=$(echo "$tags_response" \
              | jq -r '.[].name' \
              | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
              | sort -V \
              | tail -n 1)
            
              if [ -z "$current_version" ]; then
                current_version="0.0.0"
              fi
            fi
          
            echo "  Current: $current_version"
            echo "  Target:  $target_version"
          
            # Compare versions directly
            if version_gt "$target_version" "$current_version"; then
              echo "  → New version detected! Releasing $target_version"
          
              # Clean up any existing temp directory for this package
              rm -rf "temp-$package"
          
              # Clone individual repo and tag it
              if ! git clone "https://${{ secrets.SYNC_TOKEN }}@github.com/quellabs/$package.git" "temp-$package" 2>/dev/null; then
                echo "  ❌ Failed to clone $package repository"
                continue
              fi
          
              cd "temp-$package"
          
              # Check if tag already exists
              if git tag -l | grep -q "^$target_version$"; then
                echo "  ❌ Tag $target_version already exists in $package"
                cd ..
                rm -rf "temp-$package"
                continue
              fi
          
              # Create and push tag
              if [ "$DRY_RUN" = "true" ]; then
                echo "  🔍 DRY RUN: Would tag $package with $target_version"
              elif git tag -a "$target_version" -m "Release $target_version" && \
                 git push origin "$target_version"; then
                 echo "  ✅ Tagged $package with $target_version"
              else
                 echo "  ❌ Failed to tag or push $package. Diagnostics:"
                 echo "  → Last few commits:"
                 git log -3 --oneline || true
                 echo "  → Git status:"
                 git status || true
                 echo "  → Existing tags:"
                 git tag --sort=-creatordate | head -5 || true
              fi
          
              cd ..
              rm -rf "temp-$package"
            elif [ "$current_version" = "$target_version" ]; then
              echo "  ✅ Already up to date"
            else
              echo "  ⚠️  Target version ($target_version) is older than current ($current_version)"
            fi
          done