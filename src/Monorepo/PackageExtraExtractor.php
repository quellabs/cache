<?php
	
	namespace App\Monorepo;
	
	use FilesystemIterator;
	
	class PackageExtraExtractor {
		
		/**
		 * Directory where packages are stored
		 * @var string
		 */
		private string $packagesDir;
		
		/**
		 * PackageExtraExtractor constructor
		 * @param string $packagesDir
		 */
		public function __construct(string $packagesDir) {
			$this->packagesDir = rtrim($packagesDir, '/');
		}
		
		/**
		 * Extract all 'extra' sections from composer.json files in packages directory
		 * @return array Array with package name as key and extra section as value
		 * @throws \RuntimeException if packages directory doesn't exist
		 */
		public function getMap(): array {
			// Validate that the packages directory exists before proceeding
			if (!is_dir($this->packagesDir)) {
				throw new \RuntimeException("Packages directory '{$this->packagesDir}' does not exist");
			}
			
			// Find all composer.json files in the packages directory
			// Process each composer.json file found
			$result = [];

			foreach ($this->findComposerFiles() as $composerFile) {
				// Parse the composer.json file to get package data
				$packageData = $this->parseComposerFile($composerFile);
				
				// Only process packages that have valid data and contain an 'extra' section
				if ($packageData && !empty($packageData['extra'])) {
					// Get the package name (either from 'name' field or derive from file path)
					$packageName = $this->getPackageName($packageData, $composerFile);
					
					// Store the extra section using package name as key
					$result[$packageName] = $packageData['extra'];
				}
			}
			
			return $result;
		}
		
		/**
		 * Write the extra map to a PHP file
		 * @param string $outputPath Full path where the file should be written
		 * @param array $extraMap The complete mapping of package names to extra data
		 * @throws \RuntimeException If the file cannot be written
		 */
		public function writeExtraMapFile(string $outputPath, array $extraMap): void {
			$timestamp = date('Y-m-d H:i:s');
			$count = count($extraMap);
			
			// Generate the PHP file header with metadata
			$content = <<<PHP
<?php
/**
 * Auto-generated by Discover
 * Generated on: {$timestamp}
 * Total packages with extra data: {$count}
 *
 * This file is automatically generated by the ServiceDiscoveryPlugin.
 * Do not edit manually as changes will be overwritten.
 *
 * Format: "package_name" => complete extra block
 */

return
PHP;
			
			// Add the formatted array data
			$content .= $this->varExportPretty($extraMap, 0);
			$content .= ";\n";
			
			// Write the content to the file
			if (file_put_contents($outputPath, $content) === false) {
				throw new \RuntimeException("Failed to write extra map to: {$outputPath}");
			}
		}
		
		/**
		 * Pretty print var_export with proper indentation
		 * @param mixed $var The variable to format (typically an array)
		 * @param int $indent Current indentation level (used for recursion)
		 * @return string Formatted PHP code representation of the variable
		 */
		private function varExportPretty(mixed $var, int $indent = 0): string {
			// Create the indentation string based on current level
			$indentStr = str_repeat('    ', $indent);
			
			if (is_array($var)) {
				// Handle empty arrays
				if (empty($var)) {
					return '[]';
				}
				
				// Determine if this is an associative array or indexed array
				$isAssoc = array_keys($var) !== range(0, count($var) - 1);
				$output = "[\n";
				
				// Process each array element
				foreach ($var as $key => $value) {
					$output .= $indentStr . '    ';
					
					// For associative arrays, include the key
					if ($isAssoc) {
						$output .= var_export($key, true) . ' => ';
					}
					
					// Recursively format the value with increased indentation
					$output .= $this->varExportPretty($value, $indent + 1);
					$output .= ",\n";
				}
				
				$output .= $indentStr . ']';
				return $output;
			}
			
			// For non-arrays, use standard var_export
			return var_export($var, true);
		}
		
		/**
		 * Find all composer.json files in the packages directory
		 * @return array Array of file paths
		 */
		private function findComposerFiles(): array {
			// Initialize array to store found composer.json file paths
			$composerFiles = [];
			
			// Create a recursive iterator to traverse all subdirectories
			// RecursiveDirectoryIterator: Creates iterator for directory structure
			// SKIP_DOTS flag: Excludes '.' and '..' directory entries
			// RecursiveIteratorIterator: Flattens the recursive structure for easy iteration
			$iterator = new \RecursiveIteratorIterator(
				new \RecursiveDirectoryIterator($this->packagesDir, FilesystemIterator::SKIP_DOTS),
				\RecursiveIteratorIterator::LEAVES_ONLY
			);
			
			// Only immediate subdirectories (depth 1)
			// This will look in packages/package-name/ but not packages/package-name/src/
			$iterator->setMaxDepth(1);
			
			// Iterate through all files and directories recursively
			foreach ($iterator as $file) {
				// If the current file is named 'composer.json'
				// add the full file path to our result array
				if ($file->getFilename() === 'composer.json') {
					$composerFiles[] = $file->getPathname();
				}
			}
			
			// Return array of all composer.json file paths found
			return $composerFiles;
		}
		
		/**
		 * Parse composer.json file and return decoded data
		 * @param string $filePath Path to composer.json file
		 * @return array|null Decoded composer data or null on failure
		 */
		private function parseComposerFile(string $filePath): ?array {
			try {
				// Attempt to read the entire file contents into a string
				$content = file_get_contents($filePath);
				
				// Check if file reading failed (returns false on failure)
				if ($content === false) {
					error_log("Failed to read composer.json at: {$filePath}");
					return null;
				}
				
				// Decode the JSON content into an associative array
				// Second parameter 'true' ensures we get an array instead of an object
				$data = json_decode($content, true);
				
				// Check if JSON parsing encountered any errors
				if (json_last_error() !== JSON_ERROR_NONE) {
					// Log the specific JSON error message for debugging
					error_log("Invalid JSON in composer.json at: {$filePath} - " . json_last_error_msg());
					return null;
				}
				
				// Successfully parsed - return the decoded data
				return $data;
			} catch (\Exception $e) {
				// Catch any unexpected exceptions (file system errors, etc.)
				error_log("Error parsing composer.json at {$filePath}: " . $e->getMessage());
				return null;
			}
		}
		
		/**
		 * Get package name from composer data or fallback to directory name
		 * @param array $packageData Decoded composer.json data
		 * @param string $filePath Path to composer.json file
		 * @return string Package name
		 */
		private function getPackageName(array $packageData, string $filePath): string {
			// Use the 'name' field if available
			if (!empty($packageData['name'])) {
				return $packageData['name'];
			}
			
			// Fallback to directory name
			return basename(dirname($filePath));
		}
	}